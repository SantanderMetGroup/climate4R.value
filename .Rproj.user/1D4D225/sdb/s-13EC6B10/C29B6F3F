{
    "collab_server" : "",
    "contents" : "#     valueMeasure.R Bias correction methods\n#\n#     Copyright (C) 2017 Santander Meteorology Group (http://www.meteo.unican.es)\n#\n#     This program is free software: you can redistribute it and/or modify\n#     it under the terms of the GNU General Public License as published by\n#     the Free Software Foundation, either version 3 of the License, or\n#     (at your option) any later version.\n# \n#     This program is distributed in the hope that it will be useful,\n#     but WITHOUT ANY WARRANTY; without even the implied warranty of\n#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#     GNU General Public License for more details.\n# \n#     You should have received a copy of the GNU General Public License\n#     along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n#' @title VALUE measure calculation for climate4R grids\n#' @description VALUE measure calculation for climate4R grids\n#' @param y Grid (also station data) of observations\n#' @param x Grid (also station data) of the grid that is being validated\n#' @param measure.code characher of the measure code to be computed (use VALUE::show.measures)\n#' @param index.code Default is NULL. characher of the index code to be computed (use VALUE::show.indices). \n#' @param return.NApercentage Logical to also return or not a grid containing NA percentage information.\n#' @template templateParallelParams \n#' @details Some measures are computed directly from the original time series (e.g. temporal correlation),\n#' whereas others are computed upon previouly computed indices (e.g. mean bias). \n#' Thus, argument \\code{index.code} must be provided for the latter case.\n#' @return A grid of the index or a list containing the grid of the index and the \n#' grid of NA percenatage\n#' @importFrom abind abind adrop\n#' @import transformeR\n#' @importFrom VALUE valueMeasure1D valueIndex1D\n#' @author M. Iturbide\n#' @export\n#' @examples \n# library(transformeR)\n# y <- EOBS_Iberia_tas\n# x <- CFS_Iberia_tas\n# bias <- valueMeasure(y, x, measure.code = \"bias\", index.code = \"mean\")\n# str(bias$Measure)\n# str(bias$NAmeanPercentage)\n\nvalueMeasure <- function(y, x, \n                         measure.code, \n                         index.code = NULL,\n                         return.NApercentage = TRUE,\n                         parallel = FALSE,\n                         max.ncores = 16,\n                         ncores = NULL){\n  if (any(c(\"biasCirc\", \"bias\", \"biasRel\", \"ratio\") %in% measure.code)) {\n    if (is.null(index.code)) stop(\"This measure requires previous index calculation. Please provide an index.code (Use VALUE::show.indices() to choose an index).\")\n    index.y <- valueIndex(grid = y, index.code = index.code, parallel = parallel, max.ncores = max.ncores, ncores = ncores)\n    index.x <- valueIndex(grid = x, index.code = index.code, parallel = parallel, max.ncores = max.ncores, ncores = ncores)\n    y <- index.y[[\"Index\"]]\n    x <- index.x[[\"Index\"]]\n    na.percent <- index.y[[\"NApercentage\"]]\n    rm(index.y, index.x)\n  }\n  station <- FALSE\n  if (\"loc\" %in% getDim(y)) station <- TRUE\n  xy <- y$xyCoords\n  dimNames <- attr(redim(y, member = FALSE, loc = station)$Data, \"dimensions\")\n  suppressWarnings(suppressMessages(ix <- interpGrid(x, getGrid(y))))\n  y <- redim(y, drop = TRUE)\n  y <- redim(y, member = FALSE, runtime = FALSE)\n  ix <- redim(ix, member = TRUE, runtime = TRUE)\n  out <- ix\n  n.run <- getShape(ix)[\"runtime\"]\n  n.mem <- getShape(ix)[\"member\"]\n  runarr <- lapply(1:n.run, function(l) {\n    memarr <- lapply(1:n.mem, function(m) {\n      message(\"[\", Sys.time(), \"] Computing member \", m, \" out of \", n.mem)\n      o = y$Data[, , , drop = FALSE]\n      p = adrop(ix$Data[l, m, , , , drop = FALSE], drop = c(T, T, F, F, F))\n      data <- list(o, p)\n      if (!station) {\n        data <- lapply(1:length(data), function(x) {\n          attr(data[[x]], \"dimensions\") <- c(\"time\", \"lat\", \"lon\")\n          abind(array3Dto2Dmat(data[[x]]), along = 3)\n        }) \n      }\n      o <- lapply(seq_len(ncol(data[[1]])), function(i) data[[1]][,i,1])\n      p <- lapply(seq_len(ncol(data[[2]])), function(i) data[[2]][,i,1])\n      nona.o <- lapply(o, function(x) which(!is.na(x)))\n      nona.p <- lapply(p, function(x) which(!is.na(x)))\n      sea <- unlist(lapply(1:length(nona.o), function(x) {\n        if (length(nona.o[[x]]) == 0 | length(nona.p[[x]]) == 0)  x\n      }))\n      nonaind <- lapply(1:length(nona.o), function(x) {\n        if (length(nona.o[[x]]) != 0 && length(nona.p[[x]]) != 0)  {\n          intersect(nona.o[[x]] , nona.p[[x]])\n        } else {\n          1:length(y$Dates$start)\n        }\n      })\n      dates <- list()\n      for (i in 1:length(nonaind)) {\n        dates[[i]] <- y$Dates$start[nonaind[[i]]]\n        o[[i]] <- o[[i]][nonaind[[i]]]\n        p[[i]] <- p[[i]][nonaind[[i]]]\n      }\n      mat <- abind(valueMeasureXD(o = o, p = p, io = o, ip = p, dates = dates, measure.code = measure.code, \n                                  parallel = parallel, max.ncores = max.ncores, ncores = ncores), \n                   along = 0)\n      na.mat <- do.call(\"abind\", \n                        list(lapply(nonaind, function(x) 100 - (length(x)/length(y$Dates$start)*100))\n                             , along = 2))\n      na.mat[1, sea] <- NA\n      if (!station) mat <- mat2Dto3Darray(mat, xy$x, xy$y)\n      if (!station) na.mat <- mat2Dto3Darray(na.mat, xy$x, xy$y)\n      list(mat, na.mat)\n    })\n    list(unname(do.call(\"abind\", list(lapply(memarr, \"[[\", 1), along = 0))),\n         unname(do.call(\"abind\", list(lapply(memarr, \"[[\", 2), along = 0))))\n  })\n  out.na <- out\n  out$Data <- unname(do.call(\"abind\", list(lapply(runarr, \"[[\", 1), along = 0)))\n  out.na$Data <- unname(do.call(\"abind\", list(lapply(runarr, \"[[\", 2), along = 0)))\n  attr(out$Data, \"dimensions\") <- unique(c(\"runtime\", \"member\", dimNames))\n  attr(out.na$Data, \"dimensions\") <- unique(c(\"runtime\", \"member\", dimNames))\n  out$Dates$start <- y$Dates$start[1]\n  out$Dates$end <- range(y$Dates$end)[2]\n  out.na$Dates$start <- y$Dates$start[1]\n  out.na$Dates$end <- range(y$Dates$end)[2]\n  if (station) out <- redim(out, loc = TRUE)\n  if (station) out.na <- redim(out.na, loc = TRUE)\n  out.na$Variable$varName <- \"NApercentage\"\n  out <- redim(out, drop = TRUE)\n  out.na <- redim(out.na, drop = TRUE)\n  message(\"[\", Sys.time(), \"] Done.\")\n  if (return.NApercentage) {\n    if (any(c(\"biasCirc\", \"bias\", \"biasRel\", \"ratio\") %in% measure.code)) { \n      return(list(\"Measure\" = out, \"NAmeanPercentage\" = na.percent))\n    } else {\n      return(list(\"Measure\" = out, \"NApercentage\" = out.na))\n    }\n  } else {\n    return(out)\n  }\n}\n#end\n\nvalueMeasureXD <- function(o = NULL, p = NULL, \n                           io = NULL, ip = NULL,\n                           dates = NULL, measure.code = NULL, \n                           parallel = FALSE,\n                           max.ncores = 16,\n                           ncores = NULL){\n  parallel.pars <- parallelCheck(parallel, max.ncores, ncores)\n  mapply_fun <- selectPar.pplyFun(parallel.pars, .pplyFUN = \"mapply\")\n  if (parallel.pars$hasparallel) on.exit(parallel::stopCluster(parallel.pars$cl))\n  mapply_fun(valueMeasure1D, obs = o, prd = p, indexObs = io, indexPrd = ip, dates, MoreArgs = list(measure.codes = measure.code))\n}\n#end\n",
    "created" : 1551270616559.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4080846781",
    "id" : "C29B6F3F",
    "lastKnownWriteTime" : 1551697810,
    "last_content_update" : 1551697810069,
    "path" : "/media/maialen/work/WORK/GIT/climate4R.value/R/valueMeasure.R",
    "project_path" : "R/valueMeasure.R",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}