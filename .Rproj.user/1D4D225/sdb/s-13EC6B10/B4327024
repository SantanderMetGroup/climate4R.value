{
    "collab_server" : "",
    "contents" : "#     valueIndex.R Bias correction methods\n#\n#     Copyright (C) 2017 Santander Meteorology Group (http://www.meteo.unican.es)\n#\n#     This program is free software: you can redistribute it and/or modify\n#     it under the terms of the GNU General Public License as published by\n#     the Free Software Foundation, either version 3 of the License, or\n#     (at your option) any later version.\n# \n#     This program is distributed in the hope that it will be useful,\n#     but WITHOUT ANY WARRANTY; without even the implied warranty of\n#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#     GNU General Public License for more details.\n# \n#     You should have received a copy of the GNU General Public License\n#     along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n#' @title VALUE measure calculation for climate4R grids\n#' @description VALUE measure calculation for climate4R grids\n#' @param grid Grid (also station data) of observations\n#' @param index.code Characher of the index code to be computed (use VALUE::show.indices). \n#' @param return.NApercentage Logical to also return or not a grid containing NA percentage information.\n#' @template templateParallelParams \n#' @return A grid of the index or a list containing the grid of the index and the \n#' grid of NA percenatage\n#' @importFrom abind adrop abind\n#' @import transformeR\n#' @importFrom VALUE valueIndex1D\n#' @author M. Iturbide\n#' @export\n#' @examples \n#' library(transformeR)\n#' y <- EOBS_Iberia_tas\n#' m <- valueIndex(y, \"mean\")\n#' str(m$Index)\n#' str(m$NApercentage)\n\nvalueIndex <- function(grid = NULL, index.code = NULL,\n                       return.NApercentage = TRUE,\n                       parallel = FALSE,\n                       max.ncores = 16,\n                       ncores = NULL){\n  station <- FALSE\n  if (\"loc\" %in% getDim(grid)) station <- TRUE\n  xy <- grid$xyCoords\n  dimNames <- attr(grid$Data, \"dimensions\")\n  grid <- redim(grid, drop = TRUE)\n  grid <- redim(grid, member = TRUE, runtime = TRUE)\n  out <- grid\n  n.run <- getShape(grid)[\"runtime\"]\n  n.mem <- getShape(grid)[\"member\"]\n  runarr <- lapply(1:n.run, function(l) {\n    memarr <- lapply(1:n.mem, function(m) {\n      message(\"[\", Sys.time(), \"] Computing member \", m, \" out of \", n.mem)\n      p = adrop(grid$Data[l, m, , , , drop = FALSE], drop = c(T, T, F, F, F))\n      if (!station) {\n          attr(p, \"dimensions\") <- c(\"time\", \"lat\", \"lon\")\n          p <- abind(array3Dto2Dmat(p), along = 3)\n      }\n      p <- lapply(seq_len(ncol(p)), function(i) p[,i,1])\n      nona.p <- lapply(p, function(x) which(!is.na(x)))\n      sea <- unlist(lapply(1:length(nona.p), function(x) {\n        if (length(nona.p[[x]]) == 0)  x\n      }))\n      nonaind <- lapply(1:length(nona.p), function(x) {\n        if (length(nona.p[[x]]) != 0)  {\n          nona.p[[x]]\n        } else {\n          1:length(grid$Dates$start)\n        }\n      })\n      dates <- list()\n      for (i in 1:length(nonaind)) {\n        dates[[i]] <- grid$Dates$start[nonaind[[i]]]\n        p[[i]] <- p[[i]][nonaind[[i]]]\n      }\n      mat <- abind(valueIndexXD(ts = p, dates = dates, index.code = index.code, \n                                  parallel = parallel, max.ncores = max.ncores, ncores = ncores), \n                   along = 0)\n      na.mat <- do.call(\"abind\", \n                        list(lapply(nonaind, function(x) 100 - (length(x)/length(grid$Dates$start)*100))\n                             , along = 2))\n      na.mat[1, sea] <- NA\n      if (!station) mat <- mat2Dto3Darray(mat, xy$x, xy$y)\n      if (!station) na.mat <- mat2Dto3Darray(na.mat, xy$x, xy$y)\n      list(mat, na.mat)\n    })\n    list(unname(do.call(\"abind\", list(lapply(memarr, \"[[\", 1), along = 0))),\n         unname(do.call(\"abind\", list(lapply(memarr, \"[[\", 2), along = 0))))\n  })\n  out.na <- out\n  out$Data <- unname(do.call(\"abind\", list(lapply(runarr, \"[[\", 1), along = 0)))\n  out.na$Data <- unname(do.call(\"abind\", list(lapply(runarr, \"[[\", 2), along = 0)))\n  attr(out$Data, \"dimensions\") <- unique(c(\"runtime\", \"member\", dimNames))\n  attr(out.na$Data, \"dimensions\") <- unique(c(\"runtime\", \"member\", dimNames))\n  out$Dates$start <- grid$Dates$start[1]\n  out$Dates$end <- range(grid$Dates$end)[2]\n  out.na$Dates$start <- grid$Dates$start[1]\n  out.na$Dates$end <- range(grid$Dates$end)[2]\n  if (station) out <- redim(out, loc = TRUE)\n  if (station) out.na <- redim(out.na, loc = TRUE)\n  out$Variable$varName <- index.code\n  out.na$Variable$varName <- \"NApercentage\"\n  out <- redim(out, drop = TRUE)\n  out.na <- redim(out.na, drop = TRUE)\n  message(\"[\", Sys.time(), \"] Done.\")\n  if (return.NApercentage) {\n    return(list(\"Index\" = out, \"NApercentage\" = out.na))\n  } else {\n    return(out)\n  }\n}\n#end\n\nvalueIndexXD <- function(ts = NULL, dates = NULL, \n                         index.code = NULL, \n                         parallel = FALSE,\n                         max.ncores = 16,\n                         ncores = NULL){\n  parallel.pars <- parallelCheck(parallel, max.ncores, ncores)\n  mapply_fun <- selectPar.pplyFun(parallel.pars, .pplyFUN = \"mapply\")\n  if (parallel.pars$hasparallel) on.exit(parallel::stopCluster(parallel.pars$cl))\n  mapply_fun(valueIndex1D, ts, dates, MoreArgs = list(index.code))\n}\n#end\n",
    "created" : 1551197753632.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2224485499",
    "id" : "B4327024",
    "lastKnownWriteTime" : 1551697805,
    "last_content_update" : 1551697805018,
    "path" : "/media/maialen/work/WORK/GIT/climate4R.value/R/valueIndex.R",
    "project_path" : "R/valueIndex.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}